#include <stdio.h>
#include <inttypes.h>
#include "sam.h"
#include "bam_hmp_util.h"

// glib
#include <glib.h>
#include <glib/gthread.h>

int new_gi = FIRST_UNKNOWN_GI;
int new_taxon_id = FIRST_UNKNOWN_TAXON_ID;

// ---------------------------------------------------------------------------------
// Functions pertaining to the processing of HMP whole metagenomic read -> 
// reference genome BAM files, and the mapping of the reference sequences therein 
// to NCBI taxon_ids.
//
// jonathancrabtree@gmail.com
// ---------------------------------------------------------------------------------

// Parse NCBI GIs from refseq descriptions and store GI to refseq mapping in a hashtable.
//
// bam_header      Pointer to the header for one of the alignment BAM files.
// refseq_gids     Stored NCBI GI for each target sequence in the bam_header.
//
// Returns a GHashTable mapping reference sequence NCBI GI to BAM header index
// (i.e., an index into bam_header->target_name).
//
GHashTable *build_refseq_hash(bam_header_t *bam_header, int **refseq_gids, gboolean verbose)
{
  // mapping from target sequence GI to BAM header refseq index
  // NOTE: some target sequences appear more than once in the HMP files.  In those 
  // cases the BAM header refseq index will be the index of the _first_ one found 
  // with that GI.
  GHashTable *refseq_gi_ht = g_hash_table_new(g_int_hash, g_int_equal);

  // regex to parse GI from refseq/refseq name
  GRegex *refseq_gi_re = g_regex_new("^[A-Z\\d_]+\\|gi\\|(\\d+)\\|.*", 0, 0, NULL);
  GMatchInfo *match_info = NULL;
  int gid;
  // HACK: this array (refseq_inds) is not currently freed anywhere
  int *refseq_inds = g_malloc(sizeof(int) * bam_header->n_targets);
  *refseq_gids = g_malloc(sizeof(int) * bam_header->n_targets);
  int *refseq_gids_a = *refseq_gids;
  int i;

  for (i = 0;i < bam_header->n_targets; ++i) {
    refseq_inds[i] = i;
    // parse target sequence GI and insert it into the hash table
    if (g_regex_match(refseq_gi_re, bam_header->target_name[i], 0, &match_info)) {
      while (g_match_info_matches(match_info)) {
	gchar *gi_str = g_match_info_fetch(match_info, 1);
	sscanf(gi_str, "%d", &gid);
	g_free(gi_str);
	refseq_gids_a[i] = gid;

	// check for duplicate gids
	if (g_hash_table_lookup(refseq_gi_ht, &gid) != NULL) {
	  if (verbose) fprintf(stderr, "WARN - duplicate gid=%d found in target %d: %s\n", gid, i, bam_header->target_name[i]);
	} 
	// store mapping from gid to (first) target index (since there can be multiple targets with the same gi)
	else {
	  g_hash_table_insert(refseq_gi_ht, &refseq_gids_a[i], &refseq_inds[i]);
	}
	g_match_info_next(match_info, NULL);
      }
    }
    // if no GI can be parsed, generate a dummy one
    else {
      refseq_gids_a[i] = new_gi--;
    }
    g_match_info_free(match_info); 
  }
  g_regex_unref(refseq_gi_re);
  return refseq_gi_ht;
}

// Parse NCBI GI to taxon_id mapping from tab-delimited text file.  If output_map_file is specified
// then the function will also write out the subset of the mapping that pertains to the reference
// sequence GIs in refseq_gi_ht.
//
// input_map_file  Tab-delimited NCBI GI to NCBI taxon_id mapping file to read.
// output_map_file Optional output file.  If not NULL the subset of input_map_file that
//                 corresponds to refseq_gi_ht will be written to this file.
// bam_header      Pointer to the header for one of the alignment BAM files.
// refseq_gi_ht    The refseq GI to target index mapping hashtable generated by build_refseq_hash
// target_gids     NCBI GI parsed for each refseq referenced in the bam_header.
//
// Returns a GHashTable that maps reference sequence NCBI GI to NCBI taxon_id, as per input_map_file.
//
GHashTable *read_gi_to_taxon_map(char *input_map_file, char *output_map_file, bam_header_t *bam_header, GHashTable *refseq_gi_ht, int *target_gids, gboolean verbose)
{
  // mapping from GI to taxon_id parsed from the mapping file
  GHashTable *gi_to_tid_ht = g_hash_table_new(g_int_hash, g_int_equal);

  // ---------------------------------------------------------------------------------
  // step 1: parse GI to taxon_id mapping from input_map_file
  // ---------------------------------------------------------------------------------
  GIOChannel *ofh = NULL;

  // in this mode we write out the subset of the mapping that corresponds to the input refseqs, but do nothing else
  if (output_map_file != NULL) {
    ofh = g_io_channel_new_file(output_map_file, "w", NULL);
    if (ofh == NULL) {
      fprintf(stderr, "ERROR - failed to open %s to write subset of NCBI GI -> taxon_id mapping", output_map_file);
      return NULL;
    }
  }

  // read NCBI mapping file
  fprintf(stderr, "reading %s\n", input_map_file);
  GIOChannel *fh = g_io_channel_new_file(input_map_file, "r", NULL);
  if (fh == NULL) {
    fprintf(stderr, "ERROR - failed to read from NCBI GI -> taxon_id mapping file %s\n", input_map_file);
    return NULL;
  }

  // parse NCBI GI and NCBI taxon_id from mapping file
  GRegex *ncbi_gi_re = g_regex_new("^(\\d+)\\t(\\d+)$", 0, 0, NULL);
  gchar *line;
  int linenum = 0;
  int gid;
  int tid;
  int *gids = NULL;
  int *tids = NULL;
  int tidnum = 0;
  GIOStatus rs;
  gsize bytecount;
  GMatchInfo *match_info = NULL;

  // only store GI -> taxon_id mapping when not running on the full mapping file (which is very large)
  if (output_map_file == NULL) {
    // HACK: these arrays aren't currently freed anywhere
    gids = g_malloc(sizeof(int) * bam_header->n_targets);
    tids = g_malloc(sizeof(int) * bam_header->n_targets);
  }

  while (rs = g_io_channel_read_line(fh, &line, NULL, NULL, NULL)) {
    if ((line == NULL) || (rs != G_IO_STATUS_NORMAL)) break;
    ++linenum;

    // apply regex to parse GI and taxon_id, check whether GI is needed, and store the mapping if so
    if (g_regex_match(ncbi_gi_re, line, 0, &match_info)) {
      while (g_match_info_matches(match_info)) {
	gchar *gi_str = g_match_info_fetch(match_info, 1);
	gchar *tid_str = g_match_info_fetch(match_info, 2);
	sscanf(gi_str, "%d", &gid);
	g_free(gi_str);
	sscanf(tid_str, "%d", &tid);
	g_free(tid_str);

	// check gi against hashtable of all refseq gis, store mapping if it matches
	if (g_hash_table_lookup(refseq_gi_ht, &gid) != NULL) {
	  // sanity check 
	  if (tidnum > bam_header->n_targets) {
	    fprintf(stderr, "ERROR - read more than %d distinct taxon_ids", bam_header->n_targets);
	    return NULL;
	  }

	  // either store the mapping from GI to taxon_id for later use
	  if (output_map_file == NULL) {
	    gids[tidnum] = gid;
	    tids[tidnum] = tid;
	    g_hash_table_insert(gi_to_tid_ht, &gids[tidnum], &tids[tidnum]);
	  }

	  // OR echo the relevant line to the output file
	  if (ofh != NULL) {
	    GIOStatus ws = g_io_channel_write_chars(ofh, line, -1, &bytecount, NULL);
	    if (ws != G_IO_STATUS_NORMAL) {
	      fprintf(stderr, "ERROR - GLib error writing to %s\n", output_map_file);
	      return NULL;
	    }
	  }
	  ++tidnum;
	}
	g_match_info_next(match_info, NULL);
      }
    } else {
      fprintf(stderr, "ERROR - couldn't parse line %d of %s\n", linenum, input_map_file);
      return NULL;
    }
    g_match_info_free(match_info);
    if (line != NULL) g_free(line);

    // print progress updates
    if ((linenum % PROGRESS_INTERVAL_ROWS) == 0) {
      if (verbose) fprintf(stderr, "INFO - read progress: %d line(s), %d recorded taxon id(s)\n", linenum, tidnum);
    }
  }

  if ((rs != G_IO_STATUS_NORMAL) && (rs != G_IO_STATUS_EOF)) {
    fprintf(stderr, "ERROR - GLib error reading from %s\n", input_map_file);
    return NULL;
  }

  fprintf(stderr, "read %d line(s) from %s and recorded %d GI -> taxon_id mapping(s) for %d distinct refseqs\n", linenum, input_map_file, tidnum, bam_header->n_targets);
  g_regex_unref(ncbi_gi_re);
  g_io_channel_shutdown(fh, TRUE, NULL);
  if (ofh != NULL) g_io_channel_shutdown(ofh, TRUE, NULL);

  // ---------------------------------------------------------------------------------
  // step 2: generate dummy GI and taxon_ids for any reference seqs that lack either
  // ---------------------------------------------------------------------------------
  // count affected refseqs
  int refseqs_no_gi = 0;
  int refseqs_no_ti = 0;
  // hashtable of newly-generated taxon_ids, indexed by organism name
  GHashTable *new_taxon_id_ht = g_hash_table_new(g_str_hash, g_str_equal);
  // HACK: this array isn't currently freed anywhere
  int *target_tids = g_malloc(sizeof(int) * bam_header->n_targets);
  int i;

  for (i = 0;i < bam_header->n_targets; ++i) {
    if (target_gids[i] <= FIRST_UNKNOWN_GI) {
      if (verbose) fprintf(stderr, "WARN - no GI found for target %d: %s\n", i, bam_header->target_name[i]);
      ++refseqs_no_gi;
    }
    int *taxon_id = (int *)g_hash_table_lookup(gi_to_tid_ht, &target_gids[i]);
    if (taxon_id == NULL) {
      // only count those that have a GI but no taxon id
      if (target_gids[i] > FIRST_UNKNOWN_GI) {
	if (verbose) fprintf(stderr, "WARN - no taxon_id found for target %d: %s\n", i, bam_header->target_name[i]);
	++refseqs_no_ti;
      }

      // parse organism name from target name
      // HACK - this is specific to the HMP query sequence set
      GString *org_name = NULL;
      GRegex *org_name_re = g_regex_new("\\|([a-zA-Z\\_\\.\\d\\-]+)\\_Cont\\d+\\.\\d+\\|", 0, 0, NULL);
      GMatchInfo *org_match_info = NULL;

      if (g_regex_match(org_name_re, bam_header->target_name[i], 0, &org_match_info)) {
	while (g_match_info_matches(org_match_info)) {
	  gchar *m1 = g_match_info_fetch(org_match_info, 1);
	  org_name = g_string_new(m1);
	  // NOTE - not freeing org_name since it will be used as a hashtable key
	  g_match_info_next(org_match_info, NULL);
	}
      } else {
	fprintf(stderr, "ERROR - unable to parse organism name from the following refseq name: %s\n", bam_header->target_name[i]);
	return NULL;
      }
      g_match_info_free(org_match_info);
      g_regex_unref(org_name_re);
      
      // generate a new taxon_id, if necessary, and assign this gi to it
      taxon_id = (int *)g_hash_table_lookup(new_taxon_id_ht, org_name->str);
      if (taxon_id == NULL) {
	target_tids[i] = new_taxon_id--;
	if (verbose) fprintf(stderr, "INFO - assigning new taxon_id=%d to '%s'\n", target_tids[i], org_name->str);
	g_hash_table_insert(new_taxon_id_ht, org_name->str, &target_tids[i]);
	taxon_id = &target_tids[i];
      } else {
	target_tids[i] = *taxon_id;
      }
      g_hash_table_insert(gi_to_tid_ht, &target_gids[i], &target_tids[i]);
    }
    target_tids[i] = *taxon_id;
  }

  fprintf(stderr, "found %d/%d refseqs with no GI\n", refseqs_no_gi, bam_header->n_targets);
  fprintf(stderr, "found %d/%d refseqs with a GI but no taxon_id\n", refseqs_no_ti, bam_header->n_targets);

  return gi_to_tid_ht;
}
